/*如果当前是 左半 → 上一层是 0 → 当前是 0；上一层是 1 → 当前是 1
如果当前是 右半 → 上一层是 0 → 当前是 1；上一层是 1 → 当前是 0
0->01, 1->10
显然，对于左半不用管，对于右半，只需要1-x就行了。

*/

/*比如第n行第a位是几，就需要考虑a对应的第n-1行是哪位数字
n如果是奇数，那么(n+1)/2就是在n-1行对应的生成数字，偶数那么n/2就是了。

比如第四行第6位，对应第三行第3位，对应第二行第二位，对应第一行第一位，
这样子就是0->01[1]->10[1]-10[0], 
*/
/*
class Solution {
public:
    int kthGrammar(int n, int k) {
        int result = 0;  // 假设第1行是 0
        
        while (n > 1) {
            if (k % 2 == 0) {
                // 偶数 → 右半 → 翻转
                result = 1 - result;
            }
            // else: 奇数 → 左半 → 不变
            
            k = (k + 1) / 2;  // 倒推到上一行
            n--;
        }
        
        return result;
    }
};    
*/
/*或者*/
class Solution {
public:
    int kthGrammar(int n, int k) {
        if (n == 1) return 0;  // 第1行第1位必为 0
        
        int parent = kthGrammar(n - 1, (k + 1) / 2);  // 递归找“父节点”
        //注意如果是偶数2a=c，那么c++里，（2a+1）/2=c
        //奇数a那a+1 / 2 = b
        
        
        if (k % 2 == 1) {
            // 奇数位 → 左半 → 和父节点相同
            return parent;
        } else {
            // 偶数位 → 右半 → 和父节点相反
            return 1 - parent;
        }
        //由于是传入“父级位置”，再在递归里找父级的父级直到第一行，
        //然后才判断返回些什么
        //所以n>1的层级（包括n本身)都可以依赖后来的根据父级的节点来判定
        /*递归返回结构：
        n=2,k=2
        
        parent= kt(1, 1)=0;
        ↓
        函数return = 1.
        
        n=3, k=3
        parent= kt(2, 2)=0;
        ↓
        函数return = 0.
        */
    }
};
