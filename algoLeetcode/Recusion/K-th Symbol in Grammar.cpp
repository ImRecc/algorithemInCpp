/*如果当前是 左半 → 上一层是 0 → 当前是 0；上一层是 1 → 当前是 1
如果当前是 右半 → 上一层是 0 → 当前是 1；上一层是 1 → 当前是 0
0->01, 1->10
显然，对于左半不用管，对于右半，只需要1-x就行了。

*/

/*比如第n行第a位是几，就需要考虑a对应的第n-1行是哪位数字
n如果是奇数，那么(n+1)/2就是在n-1行对应的生成数字，偶数那么n/2就是了。

比如第四行第6位，对应第三行第3位，对应第二行第二位，对应第一行第一位，
这样子就是0->01[1]->10[1]-10[0], 
*/

class Solution {
public:
    int kthGrammar(int n, int k) {
        int result = 0;  // 假设第1行是 0
        
        while (n > 1) {
            if (k % 2 == 0) {
                // 偶数 → 右半 → 翻转
                result = 1 - result;
            }
            // else: 奇数 → 左半 → 不变
            
            k = (k + 1) / 2;  // 倒推到上一行
            n--;
        }
        
        return result;
    }
};       
